//KEDOS123

#include<bits/stdc++.h>
#include "ext/pb_ds/assoc_container.hpp"
#include "ext/pb_ds/tree_policy.hpp"
#include "ext/rope"

using namespace std;

#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL);
#define mp make_pair
#define all(a) a.begin(),a.end()
#define pb push_back
#define fi first
#define se second
#define FOR(i, a, b) for (int i = a; i < b; i++)
#define ROF(i, a, b) for (int i = b; i >= a;i--)
#define minheap(a) priority_queue <a, vector<a>, greater<a> >
#define maxheap(a) priority_queue<a> 
#define eb emplace_back
#define sz(x) ((int)(x).size())
#define len(x) ((int)(x).length())
#define vd vector<double>
#define vs vector<string>\
#define ms(x,y) memset(x,y,sizeof(x))
#define umap unordered_map<int,int>
#define lb lower_bound
#define ub upper_bound

#define INF 1000000000000000000
#define inf 1000000000
#define frr(i, a, b) for (int i = (a), _b = (b); i >= _b; i--)
#define PI 3.14159265
#define pl pair<ll,ll> 
#define int long long
#define V vector
#define CIN(x) do { \
        assert(!cin.eof()); \
        cin >> x; \
        assert(!cin.fail()); \
} while(0);
#if DEBUG
#define debug_print(...) _debug_print(__VA_ARGS__)
#define debug_printf(...) printf(__VA_ARGS__)
#define debug_print_time _debug_print_time
#else // DEBUG
#define debug_print(...)
#define debug_printf(...)
#define debug_print_time
#endif // DEBUG 
#define EPS 1e-9
#define rep(i, n) for (int i = 0, _n = (n); i < _n; i++)
#define double long double
#define f(a,b,c) for(int a=b;a<=c;a++)
#define fd(a,b,c) for(int a=b;a>=c;a--)
const int MOD = 1000000007;


typedef vector<vector<int>> vvi;
typedef vector<int> vi;
typedef vector<bool> vb;
typedef pair<int, int> pii;
typedef long long ll;
typedef vector<ll> vll;
typedef double ld;
typedef vector<pii> vii;

typedef tuple<ll, ll> t2;
typedef tuple<ll, ll, ll> t3;
typedef tuple<ll, ll, ll, ll> t4;
typedef tuple<ll, ll, ll, ll, ll> t5;

//-----------INLINE FUNC---------

inline bool max3(ll a,ll b,ll c) {return max(a,max(b,c));}
inline bool min3(ll a,ll b,ll c){return min(a,min(b,c));}
inline bool sortbythis(pl a,pl b){return ((a.fi==b.fi && a.se<b.se)|| (a.fi<b.fi));}
inline bool sortbythat(pl a,pl b){return ((a.se == b.se && a.fi<b.fi)||(a.se<b.se));}
ll GCD(ll x,ll y){ if(y == 0) return x; if(x>y) return GCD(y,x%y); return GCD(x,y%x);}
ll LCM(ll x,ll y){ return (x/GCD(x,y))*y;}
ll MPOW(ll a,ll b,ll m = LLONG_MAX){if(b == 0) return 1; if(b&1)return ((a%m)*(MPOW(a,b-1,m)%m))%m; a = (a*a)%m; return (MPOW(a,b/2,m));}
ll MINV(ll a,ll m){return MPOW(a,m-2,m);}

inline ll add(ll a,ll b)
{
    ll ADD = (a % MOD + b % MOD) % MOD;
    return ADD;
}

inline ll sub(ll a,ll b)
{
    ll SUB = (a - b + MOD) % MOD;
    return SUB;
}

inline ll mul(ll a,ll b)
{
    ll MUL = (a % MOD * b % MOD) % MOD;
    return MUL;
}


//----------Template classes-------

template <typename T, typename G>
ostream& operator << (ostream& out, const pair <T, G> &a) 
{return out << "( " << a.x << ", " << a.y << ")";}
 
template <typename T>
ostream& operator << (ostream& out, const vector <T> &a) 
{out << "[ "; for(const auto &i: a) out << i << ", "; return out << "]" << endl;}
 
template <typename T>
ostream& operator << (ostream& out, const set <T> &a) 
{out << "{ "; for(const auto &i: a) out << i << ", "; return out << "}" << endl;}
 
template <typename T, typename G>
ostream& operator << (ostream& out, const map <T, G> &a) 
{out << "< "; for(const auto &i: a) out << i << ", "; return out << ">" << endl;}
 
template <typename T, size_t N>
typename enable_if<!is_same <typename remove_cv <T>::type, char>::value,
ostream&>::type operator << (ostream& out, T (&a)[N])
{out << "[ "; for(const auto &i: a) out << i << ", "; return out << "]" << endl;}
 
void debug_out(){cerr << endl;} 

template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T)
{cerr << (H) << ' '; debug_out(T...);}
template <typename A, typename B>                         void trace(const pair <A, B> &x)         { cerr << '{'; trace(x.first); cerr << ','; trace(x.second); cerr << '}'; }
template <typename A, typename B, typename C>             void trace(const tuple <A, B, C> &x)     { cerr << '{'; trace(get <0> (x)); cerr << ','; trace(get <1> (x)); cerr << ','; trace(get <2> (x)); cerr << '}'; }
template <typename A, typename B, typename C, typename D> void trace(const tuple <A, B, C, D> &x)  { cerr << '{'; trace(get <0> (x)); cerr << ','; trace(get <1> (x)); cerr << ','; trace(get <2> (x)); cerr << ','; trace(get <3> (x)); cerr << '}'; }
template <typename T>                                     void trace(const T &x)                   { int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? "," : ""), trace(i); cerr << "}"; }
template <size_t N>                                       void trace(bitset <N> v)                 { cerr << '{'; for (size_t i = 0; i < N; i++) cerr << static_cast <char> ('0' + v[i]); cerr << '}'; }
void _print()                                                                                      { cerr << "]\n"; }
template <typename T, typename... V>                      void _print(T t, V... v)                 { trace(t); if (sizeof...(v)) cerr << ", "; _print(v...); }
template <class T> bool MIN(T &a, T b)                 { return a > b ? (a = b, true) : false; }
template <class T> bool MAX(T &a, T b)                 { return a < b ? (a = b, true) : false; }

template <typename T> T binaryExpo(T a, T p)           { if (p == 0) { return 1LL; } if (p == 1) { return a; } if (p & 1) { return a * binaryExpo(a, p - 1); } T ret = binaryExpo(a, p / 2); return ret * ret; }
template <typename T> T bigMod(T a, T p, T m)          { if (p == 0) { return 1LL % m; } if (p == 1) { return a % m; } if (p & 1) { return (a % m * bigMod(a, p - 1, m)) % m; } T ret = bigMod(a, p / 2, m) % m; return (ret * ret) % m; }
template <typename T> T modInv(T a, T m)               { return bigMod(a, m - 2, m); }
template<typename... Ts>
std::istream &operator>>(std::istream &in, std::tuple<Ts...> &t);

template<typename T, typename U>
std::istream &operator>>(std::istream &in, std::pair<T, U> &p) {
  in >> p.first >> p.second;
  return in;
}
 
template<typename T>
std::istream &operator>>(std::istream &stream, std::vector<T> &vec) {
  for (auto &x : vec)
    stream >> x;
  return stream;
}
 
#if __cplusplus >= 201703L
template<typename... Ts>
std::istream &operator>>(std::istream &in, const std::tuple<Ts...> &t) {
  std::apply([&in](auto &... args) { ((in >> args), ...); }, t);
  return in;
}
 
template<class... Args> void scan(Args &... args) {
  ((std::cin >> args), ...);
}
#endif
 
template<typename T>
std::ostream &operator<<(std::ostream &out,
                         const std::vector<std::vector<T>> &t) {
  bool is_first = true;
  for (const auto &row : t) {
    if (is_first)
      is_first = false;
    else
      out << '\n';
    out << row;
  }
  return out;
}

template<class T >
ostream& operator<<(ostream& o,vector<T> v)
{
	for(T x : v)o<<x<<' ';
	o<<endl;
	return o;
}

template<class T ,class T1>
ostream& operator<<(ostream& o,map<T,T1> v)
{
	for(auto x : v)o<<x.first<<' '<<x.second<<endl;
	o<<endl;
	return o;
}

template<class T >
ostream& operator<<(ostream& o,set<T> v)
{
	for(T x : v)o<<x<<' ';
	o<<endl;
	return o;
}

template<typename T,typename T2>
int* find(T& v,T2 x) {return find(v.begin(),v.end(),x);}
template<typename T,typename T2>
int* lower_bound(T& v,T2 x){return lower_bound(v.begin(),v.end(),x);}
template<typename T,typename T2>
int* upper_bound(T& v,T2 x){return upper_bound(v.begin(),v.end(),x);}
template<typename T,typename T2>
void sort(vector<T>& v,T2 x){sort(v.begin(),v.end(),x);}
template<typename T>
void sort(vector<T>& v){sort(v.begin(),v.end());}

template<class T >
ostream& operator<<(ostream& o,multiset<T> v)
{
	for(T x : v)o<<x<<' ';
	o<<endl;
	return o;
}

template<class T,class T2 >
ostream& operator<<(ostream& o,pair<T,T2> v)
{
	o<<v.first<<' '<<v.second<<endl;
	return o;
}

template<class T1,class T2>
T2 min(T1 a,T2 b) {return min((T2)a,b);}
template<class T1,class T2>
T2 max(T1 a,T2 b) {return max((T2)a,b);}
template<typename T>
using MaxHeap = std::priority_queue<T>;
template<typename T>
using MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;

template<typename T>
inline bool chmax(T &a, T b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}

template<typename T>
inline bool chmin(T &a, T b) {
    if (a > b) {
        a = b;
        return true;
    }
    return false;
}
 
template<typename T>
void vdeb(std::vector<T> &da) {
    for (int i = 0;i < da.size();i++) {
        if (i == da.size() - 1) std::cout << da[i];
        else std::cout << da[i] << ' ';
    }
    std::cout << std::endl;
}

template<typename T>
void vdeb(std::vector<std::vector<T>> &da) {
    for (int i = 0;i < da.size();i++) vdeb(da[i]);
    std::cout << std::endl;
}

template<typename T>
void print(T ar[], int n, int s=0)
{
    for (int i = s; i < n; i++)
    {
        cout << ar[i] << " ";
    }
    cout << endl;
}
 
template<typename T>
void print(vector<T> &vec, int n=-1, int s=0)
{
    if(n==-1) {n = vec.size();}
    FOR (i, s, n) { cout << vec[i] << " ";}
    cout << endl;
}
 
template<typename T>
void initialise(T ar[], int n) {FOR(i,0,n) {cin >> ar[i];}}
 
template<typename T>
void initialise(vector<T> ar, int n=-1)
{
    if(n==-1) {n = ar.size();}
    FOR(i,0, n) {cin >> ar[i];}
}

//-------------TEMPLATE CLASSES ENDS--------
    
//-------------OTHER CLASSES START -----    

class pnc
{
  ll FACTMAX,MODU;
  vll fact;
public:
	pnc(ll n,ll m){FACTMAX = n;MODU = m;fact.resize(n+1);MFACT_INIT(MODU);}
	void MFACT_INIT(ll m){fact[0] = 1; FOR(i,1,FACTMAX+1) fact[i] = (i*fact[i-1])%MODU;}
	ll MFACT(ll n){return fact[n];}
	ll PERM(ll n,ll r){return (fact[n]*MINV(fact[n-r],MOD))%MODU;}
	ll COMB(ll n,ll r){return (PERM(n,r)*MINV(fact[r],MODU))%MODU;}
};

class UF    {
public:
    int *id, cnt, *sz;
 
	// Create an empty union find data structure with N isolated sets.
    UF(int N)   {
        cnt = N;
	id = new int[N];
	sz = new int[N];
        for(int i=0; i<N; i++)	{
            id[i] = i;
	    sz[i] = 1;
	}
    }
    ~UF()	{
	delete [] id;
	delete [] sz;
    }
	// Return the id of component corresponding to object p.
    int find(int p)	{
        int root = p;
        while (root != id[root])
            root = id[root];
        while (p != root) {
            int newp = id[p];
            id[p] = root;
            p = newp;
        }
        return root;
    }
	// Replace sets containing x and y with their union.
    void merge(int x, int y)	{
        int i = find(x);
        int j = find(y);
        if (i == j) return;
		
		// make smaller root point to larger one
        if   (sz[i] < sz[j])	{ 
		id[i] = j; 
		sz[j] += sz[i]; 
	} else	{ 
		id[j] = i; 
		sz[i] += sz[j]; 
	}
        cnt--;
    }
	// Are objects x and y in the same set?
    bool connected(int x, int y)    {
        return find(x) == find(y);
    }
	// Return the number of disjoint sets.
    int count() {
        return cnt;
    }
 
};

class Modular{
    int value;
    
public:
    Modular(long long x = 0){ value = (int)((x %MOD + MOD) % MOD); }
 
    inline Modular& operator +=(Modular x){ value += x.value; if(value >= MOD) value -= MOD; return *this; }
 
    inline Modular& operator -=(Modular x){ value -= x.value; if(value < 0) value += MOD; return *this; }
 
    inline Modular& operator *=(Modular x){ value = (int)((long long)x.value * value % MOD); return *this; }
 
    inline Modular operator -(){ return Modular(-value); }
 
    inline Modular& operator ++(){ return *this += 1; }
 
    inline Modular& operator --(){ return *this -= 1; }
 
    Modular pow(int n){ 
        while(n < 0) n += MOD - 1;
        Modular v(1), a(value);
        for(; n; a *= a, n >>= 1)
            if(n & 1) v *= a;
        return v;
    }
 
    inline Modular& operator /=(Modular x){ *this *= x.pow(-1); } //TODO : Make this Extended Euclid to handle composite moduli.
 
    inline Modular operator +(Modular x){ return x += *this; }
 
    inline Modular operator -(Modular x){ return *this + (-x); }
 
    inline Modular operator *(Modular x){ return x *= *this; }
 
    inline Modular operator /(Modular x){ return (*this) * x.pow(-1); } 
 
    inline bool operator ==(Modular x){ return value == x.value; }
 
    inline bool operator !=(Modular x){ return value != x.value; }
 
    inline operator int(){ return value; }
 
    Modular fact(){ 
        Modular x(1);
        for(int i = 1; i <= value; ++i) x *= i;
        return x;
    }
 
    friend ostream& operator <<(ostream& os, Modular x){ return os << x.value; }
 
    friend istream& operator >>(istream& is, Modular& x){ is >> x.value; x.value %= MOD; return is; }
};

//---------CLASS  ENDS------------
//global varibles
ll bb=0, vikings=0;
ll kedos=0,jai=0;
//----------ALL FUNC'S dEFINED HERE-----

void dfsC(ll x) {
	vll g[300005];
	bool all;
    for(auto next: g[x])
        if(next == (x+1)%MOD) {
            if(next == 0) all = true;
            else dfsC(next);
        }
}
 
void dfsA(ll x) {
	vll g[300005];
	bool all;
    for(auto next: g[x])
        if(next == (x-1+100)%MOD) {
            if(next == 0) all = true;
            else dfsA(next);
        }
}

int ispal(string s){
    int len=s.size();
    int flag=1;
    for(int i=0;i<len;++i){
        if(s[i]!=s[len-i-1]){
            flag=0;break;
        }
    }
    return flag;
}
 
ll sroot(ll n,ll low=1,ll high=1e9+1){
    if(low==high)return low;
    if(low==high-1){
        if(high*high<=n)return high;
        else return low;
    }
    ll mid=(low+high+1)/2;
    ll a=mid*mid;
    if(a>n)return sroot(n,low,mid-1);
    else return sroot(n,mid,high);
}

ll croot(ll n,ll low=1,ll high=1e6+1){
    if(low==high)return low;
    if(low==high-1){
        if(high*high*high<=n)return high;
        else return low;
    }
    ll mid=(low+high+1)/2;
    ll a=mid*mid*mid;
    if(a>n)return croot(n,low,mid-1);
    else return croot(n,mid,high);
}

vll Sieve(ll n)
{
	vll v;
	bool prime[n+1];
	memset(prime, true, sizeof(prime));
	for (int p=2; p*p<=n; p++)
	{
		if (prime[p] == true)
		{
			for (int i=p*p; i<=n; i += p)
			   prime[i] = false;
		}
	}
 
	FOR ( p,2,n+1)
		if (prime[p])
		   v.pb(p);
	return v;
}
 
vll primeFactors(ll n)
{
	vll v;
	if(n%2==0)
		v.pb(2);
	while (n % 2 == 0)
	   n = n/2;
 
	for (int i = 3; i <= sqrt(n); i = i + 2)
	{
		if(n%i==0)
			v.pb(i);
		while (n % i == 0)
		   n = n/i;
	}
	if (n > 2)
		v.pb(n);
	return v;
}

//------------- DISJOINT SET UNION START------------

ll fn(ll x,ll rn[]) // finding the component
{
    if(x==rn[x]) // Top of its component
        return x;
    else //making parent node of each node of the component the highest node
        return rn[x]=fn(rn[x],rn);
}

bool un(ll x,ll y,ll rn[],ll sz[])// union of components
{
    x=fn(x,rn);
    y=fn(y,rn);
    if(x==y)// if connected already
        return false;
    if(sz[x]<sz[y])// otherwise connectiing light to heavy by swapping
        swap(x,y);
    sz[x]+=sz[y];
    rn[y]=x;// making parent node;
    return true;
}

//---------------DISJOINT SET UNION END--------------

bool desc_sort(const int & lhs,const int & rhs) {return lhs>rhs;}

bool desc_pii_sort(const pii & lhs , const pii & rhs) {return lhs>rhs;}

bool second_sort(const pii & lhs , const pii & rhs)
{
    pii a,b;
    a.fi = lhs.se;
    a.se = lhs.fi;
    b.fi = rhs.se;
    b.se = rhs.fi;
    return a<b;
}

// --------------SEGMENT TREE START----------------

struct data
{
    ll seg;
    ll pref;
    ll suff;
    ll sum;
};

ll merge(ll a,ll b) {return max(a,b);}

ll t[4*200000];

void build(ll a[], ll v, ll tl, ll tr,ll par) 
{
    if (tl == tr) t[v] = a[tl];
    else 
    {
        ll tm = (tl + tr) / 2;
        build(a, v*2, tl, tm,par-1);
        build(a, v*2+1, tm+1, tr,par-1);
        
        if(par%2==1)
        t[v] = (t[2*v]|t[2*v+1]);
        else
        {
            t[v] = (t[2*v]^t[2*v+1]);
        }
    }
}

ll query(ll v, ll tl, ll tr, ll l, ll r) 
{
    if(tl>r || tr<l)
    {
        return 0;
    }
    if(tl>=l and tr<=r) return t[v];
    ll tm = (tl + tr) / 2;
    return (query(2*v, tl, tm, l, r)|query(2*v+1, tm+1, tr, l, r));
}

void update(ll v, ll tl, ll tr, ll pos, ll new_val,ll a[],ll par) 
{
    if (tl == tr) {t[v]=new_val;}
    else 
    {
        ll tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v*2, tl, tm, pos, new_val,a,par-1);
        else
            update(v*2+1, tm+1, tr, pos, new_val,a,par-1);
 
        if(par%2==1)
        t[v] = (t[2*v]|t[2*v+1]);
        else {t[v] = (t[2*v]^t[2*v+1]);}
    }
}

//---------------SEGMENT TREE END--------------

ll minsubarraysum(ll a[], ll size) 
{ 
   ll max_so_far = a[0]; 
   ll curr_max = a[0]; 
  
   FOR ( i, 0,size) 
   { 
        curr_max = max(a[i], curr_max+a[i]); 
        max_so_far = max(max_so_far, curr_max); 
   } 
   return max_so_far; 
}

vector<ll> prefix_function(string s) // find the longest proper prefix which is also the suffix of the same string from the given index i in the vector
{
    ll n = (ll)s.length();
    vll pi(n);
     FOR( i , 1, n) 
    {
        ll j = pi[i-1];
        while (j > 0 && s[i] != s[j])
            j = pi[j-1];
        if (s[i] == s[j])
            j++;
        pi[i] = j;
    }
    return pi;
}

ll findmin(ll ar[], int n, int l, int r, ll h)
{
    ll nz = 0;
    ll m = pow(10, 10);
    if (l > r) {return 0;}
    if(l==r) {return 1;}
    FOR (i, l , r+1)
    {
        if(ar[i]>h) {nz++;}
        m = min(ar[i], m);
    }
    ll ans2 = m - h;
    int ind1 = l;
    while(ind1<=r && ar[ind1]==m) {ind1++;}
    FOR ( i, ind1+1, r+1)
    {
        if(ar[i]==m)
        {
            ans2 += findmin(ar, n, ind1, i-1, m);
            ind1 = i;
            while (ind1 <= r && ar[ind1] == m) {ind1++;}
            i = ind1;
        }
    }
    if(ar[r]!=m) {ans2 += findmin(ar, n, ind1, r, m);}
    return min(nz, ans2);
}

//--------------- Coprimes till n in o(nlogn)------------- 


 
void computeTotient() 
{
	static ll N=100005;
	static ll phi[100005]; 
	static ll S[100005];
    FOR (i ,1,N+1) 
        phi[i]=i;
    
    FOR (p,2,N+1) 
    { 
        if (phi[p]==p) 
        { 
            phi[p]=p-1; 
            for(int i=2*p;i<=N;i+=p)  { phi[i]=(phi[i]/p)*(p-1);} 
        } 
    } 
}

void CoPrimes() 
{
	static ll N=100005;
	static ll phi[100005]; 
	static ll S[100005];
    computeTotient(); 
    FOR ( i , 1, N) 
        S[i]=S[i-1]+phi[i]; 
}

//--------------- FINDING COPRIME ENDS ---------------

void treefy(int i)
{
	queue<int> left;
	vll c;
	V<vll> g;
	left.push(i);
	while(!left.empty())
	{
		i=left.front();left.pop();
		if(c[i])continue;
		c[i]=1;
		for(int x:g[i])
		g[x].erase(find(g[x].begin(),g[x].end(),i)),left.push(x);
	}
}

int comb(int n,int r,int* b,int* c)
{
	if(r>n)return 0;
	return b[n]*c[n-r]%MOD*c[r]%MOD;
}

int ceil(int x,int y)
{
	return x/y+(x%y!=0);
}

int rond(float x)
{
	int y=round(x);
	if(x-y>0&&x-y-0.5>-MOD)
	return y+1;
	else return y;
}

string rev(string st)
{
	reverse(st.begin(),st.end());
	return st;
}

int floor1(int n,int k){
    if(n%k == 0 || n >= 0)return n/k;
    return (n/k)-1;
}

ll modpow(ll x, ll n, ll p)
{
	ll y =abs(n);
    ll res = 1; // Initialize result
    x = x % p;  // Update x if it is more than or
    while (y > 0)
    {
        if (y & 1)
            res = (res * x) % p;
        y = y >> 1; // y = y/2
        x = (x * x) % p;
    }
    return n < 0 ? 1 / res : res;
}


//------------ALL PREDEFINED FUNC'S ENDS HERE--------
	
//----MAIN CODE STARTS HERE---------


void kardeshuru()
{	 int knock;int tera;int baap; int aaya;
	knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;

 ll n,x,t;	knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;

    cin>>n>>x>>t;
	knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;
    ll val=min(n-1,t/x);
	knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;
    if(val==0){
	knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;
	knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;
        cout<<0<<endl;
	knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;
        return;
    }
    ll summ=max(0ll,val*(val-1)/2)+val*(n-val);
	knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;
	knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;
    cout<<summ<<endl;
	knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;knock++;knock++;tera++;baap++;aaya++;
}

//-----------HERE MAIN CODE ENDS-------------
signed main()
{

	fastio

/*#ifndef ONLINE_JUDGE
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
#endif*/

	int t=1;
	cin>>t;
	
    while(t--)
    //FOR(i,1,t+1)
    {
        //cout<<"Case #"<<i<<": ";
 		kardeshuru();
    }
}

